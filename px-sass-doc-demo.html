<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. tests, examples), we assume the server is started with
    'gulp serve' (or similar server setup) to enable correct finding of bower dependencies for local runs.
-->
<link rel="import" href="../polymer/polymer.html"/>

<link rel="import" href="css/px-sass-doc-viewer-styles.html">
<link rel="import" href="../px-clipboard/px-clipboard.html">
<link rel="import" href="../prism-element/prism-highlighter.html" />
<link rel="import" href="../px-dropdown/px-dropdown.html"/>
<link rel="import" href="px-highlighter.html" />

<!--
Element providing documentation for a requested Predix UI Sass component (design library).

##### Usage

      <px-sass-doc-viewer
        library-name="px-toggle-design"
        layer="objects"
        base-name="toggle"
        inuit-flags='["$inuit-enable-toggle--small","$inuit-enable-toggle--large","$inuit-enable-toggle--huge"]'
        usage-html='["<input id=\"toggle1\" class=\"toggle__input\" type=\"checkbox\">","<label for=\"toggle1\" class=\"toggle__label\"></label>"]'
        style-variables='["$inuit-toggle-color","$inuit-toggle-background","$inuit-toggle-border","$inuit-toggle-switch","$inuit-toggle-switch-border","$inuit-toggle-switch-shadow","$inuit-toggle-background--on","$inuit-toggle-border--on"]'
        dependencies='["https://github.com/PredixDev/px-colors-design","https://github.com/PredixDev/px-defaults-design","https://github.com/PredixDev/px-helpers-design"]'>
      </px-sass-doc-viewer>

@element px-sass-doc-viewer
@blurb Element providing documentation for a requested Predix UI Sass component (design library).
@homepage index.html
@demo index.html
-->

<dom-module id="px-sass-doc-demo">
  <template>
  <style include="px-sass-doc-viewer-styles"></style>
  <prism-highlighter></prism-highlighter>

  <section style="position: relative;" class="u-pb++ flex flex--col">
    <div class="mega-demo flex u-ph++ u-pb++">
      <!-- Style Options Sidebar -->
      <div class="properties u-ph+ u-pb+ u-mt+">
        <p class="epsilon">Style Options</p>
        <template is="dom-repeat" items="{{_computedStyleOptions}}">
          <template is="dom-if" if="{{_isEqual(item.type,'dropdown')}}">
            <div class="u-mb-">{{item.name}}:
              <div style="width: 100%;">
                <px-dropdown id="{{item.id}}" display-value="{{item.selectedValue}}">
                  <px-dropdown-content items="{{item.dropdownItems}}">
                  </px-dropdown-content>
                </px-dropdown>
              </div>
            </div>
          </template>
          <template is="dom-if" if="{{_isEqual(item.type,'boolean')}}">
            <div class="flex u-mb-">
              <input id="{{item.id}}" class="toggle__input toggle__input--small" type="checkbox" checked="{{item.selectedValue::change}}">
              <label for$="{{item.id}}" class="toggle__label toggle__label--small"></label>
              <div class="u-ml-">{{item.name}}</div>
            </div>
          </template>
        </template>
      </div>

      <!-- Demo Container -->
      <div class="demoContainer u-mt+">
        <div class="flex flex--col">
          <div class="demo u-p+">
            <div class="flex u-mb-">
              <px-highlighter highlight-target="#htmlDemoUsage" raw-target="#htmlDemo">
                <content select="[data-slot=htmlDemo]"></content>
              </px-highlighter>
              <section id="htmlDemo"></section>
            </div>
            <h4>Sass Import:</h4>
            <px-clipboard copy-from="#importDemo">
              <px-highlighter highlight-target="#importDemo">
                <content select="[data-slot=importDemo]"></content>
              </px-highlighter>
              <pre class="code u-mr-">
                <code id="importDemo" class="import-code"></code>
              </pre>
            </px-clipboard>
            <h4>HTML Usage:</h4>
            <px-clipboard copy-from="#htmlDemoUsage">
              <pre class="code u-mr-">
                <code id="htmlDemoUsage"></code>
              </pre>
            </px-clipboard>
          </div>
        </div>
      </div>
    </div>
  </section>

  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-sass-doc-demo',

    /**
     * Properties block, expose attribute values to the DOM via 'notify'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
      * Array of objects representing the options that can be changed for this demo.
      * Each object should contain:
      * - {string} name - The name of the option (to place above or next to the option)
      * - {string} type - The type of the object ("dropdown" or "boolean")
      *
      * If the option will be displayed as a dropdown, provide an array of `choices` in the object:
      * - {Array} choices: An array of choices. Each should either be a string (e.g. "small") or an object
      *                    with the keys `name` and `isDefault` (e.g. { name: "small", isDefault: true })
      *
      * If the option will be displayed as a boolean, just specify a `defaultChoice`:
      * - {boolean} defaultChoice: A boolean that describes if this option should appear as `true` or `false` by default.
      *
      * @property styleOptions
      * @type Array
      */
      styleOptions: {
        type: Array,
        value: function() { return []; }
      },

      /**
      * Represents the options that are selected at the time. Used by external components to update themselves based on what options are selected.
      *
      * @property selectedOptions
      * @type Object
      */
      selectedOptions: {
        type: Object,
        value: function() { return {}; }
      },

      /**
      * PRIVATE. An array of objects that is computed from `options` to provide
      * the boilerplate we need to create
      *
      * @property _computedOptions
      * @type Array
      */
      _computedStyleOptions: {
        type: Array,
        value: function() { return []; }
      },

      /**
      * PRIVATE. An internal representation of the inserts that are defined.
      *
      * @property _inserts
      * @type Object
      */
      _inserts: {
        type: Object,
        value: function() { return {}; }
      },

      /**
      * PRIVATE. An internal representation of the whenCases that are defined.
      *
      * @property _cases
      * @type Array
      */
      _cases: {
        type: Array,
        value: function() { return []; }
      }
    },

    /**
    * Observe changes to styleOptions and _computedStyleOptions, respond
    */
    observers: [
      '_updateSelectedOptions(_computedStyleOptions.*)',
      '_computeStyleOptions(styleOptions.*)'
    ],

    /**
    * On ready, wait 50 miliseconds then updateÂ the selected options
    */
    ready: function() {
      this.async(this._updateSelectedOptions, 50);
    },

    /**
    * Creates an insert from the PxSassInsert constructor and saves an internal
    * representation to use later.
    *
    * @method createInsert
    * @param name
    * @returns {Insert}
    */
    createInsert: function(name) {
      this._inserts[name] = new PxSassInsert(name, this);
      return this._inserts[name];
    },

    /**
    * Creates a whenCase from the PxSassWhenCase constructor and saves an internal
    * representation to use later.
    *
    * @method createInsert
    * @param name
    * @returns {WhenCase}
    */
    whenOption: function(optionName) {
      var whenCase = new PxSassWhenCase(optionName, this);
      this._cases.push(whenCase);
      return whenCase;
    },

    /**
    * Computes the `options` to make the more verbose `_computedOptions` we need
    * for the px-dropdown-content component.
    *
    * @method _computeOptions
    */
    _computeStyleOptions: function() {
      this._computedStyleOptions = this.styleOptions.map(function(opt){
        if (opt.type === "dropdown") {
          return {
            name: opt.name,
            id: opt.name.replace(/ /g, '') + "SassDocDropdown",
            type: opt.type,
            dropdownItems: opt.choices.map(function(choice){
              if (typeof choice === "string") { return { "key": choice,      "val":choice }; };
              if (typeof choice === "object") { return { "key": choice.name, "val":choice.name };; };
            }),
            selectedValue: opt.choices.filter(function(choice){ return (typeof choice === "object") && (choice.isDefault) })[0].name
          }
        }
        if (opt.type === "boolean") {
          return {
            name: opt.name,
            id: opt.name.replace(/ /g, '') + "SassDocDropdown",
            type: opt.type,
            selectedValue: opt.defaultChoice
          }
        }
      });
    },

    /**
    * If _computedStyleOptions has a value run through each item, get the selectedValue,
    * and assign it to selectedOptions.
    *
    * @method _updateSelectedOptions
    */
    _updateSelectedOptions: function() {
      if (this._computedStyleOptions.length > 0) {
        // Get the selected options to use in each Insert render function
        this.selectedOptions = this._computedStyleOptions.map(function(option){
          return [ option.name, option.selectedValue ]
        });

        // Loop over each Insert and run its render function, pass the result
        var selectedOptions = this.selectedOptions,
            inserts = this._inserts;
        for (var key in inserts) {
          if (inserts.hasOwnProperty(key)) {
            var insert = inserts[key],
                insertStr = insert.render(selectedOptions);
            this.fire('px-sass-doc-demo-selected-options-changed', { insert: insert.name, string: insertStr });
          }
        }
      }
    },

    /**
    * Compares strings for dom-if logic.
    *
    * @method _isEqual
    * @param a
    * @param b
    */
    _isEqual: function(a, b) {
      return a === b;
    }
  });

  /**
  * Constructor that creates a new Insert object with special behaviors. We use it
  * to build an "insertable" string that is passed up to the parent to use in
  * building demo snippets.
  *
  * # Building Inserts
  * Insert methods are chainable. The best way to use the methods is to make changes
  * immediately after you create the Insert. Example:
  *
  *     var insert = new PxSassInsert("insertName",el).prependBase("prepend-string").joinedBy("\n")
  *
  * The following methods can be chained:
  * - prependBase
  * - appendBase
  * - joinedBy
  * - attachWhenCase
  *
  * The following methods cannot be chained:
  * - render
  * - _renderWithBase
  * - _renderWhenCases
  *
  * @constructor PxSassInsert
  * @param {string} name - The name of the insert (will be fired with events).
  * @param {Object} polymerEl - A reference to the Polymer element that owns this Insert.
  * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
  */
  var PxSassInsert = function(name, polymerEl) {
    this.name = name;
    this.polymerEl = polymerEl;

    // Register additional necessary things
    this.whenCases = [];
    this.joiner = "";

    // Register constants
    this.POSITION_PREPEND = "prepend"
    this.POSITION_APPEND = "append"

    return this;
  };

    /**
    * Adds a base to prepend to the rendered Insert. There should only be one base
    * (i.e. a prepend or append.)
    *
    * @method prependBase
    * @param {string} base - The base string we will prepend to the rendered Insert
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.prependBase = function(base) {
      this.base = { str: base, position: this.POSITION_PREPEND };
      return this;
    };

    /**
    * Adds a base to append to the rendered Insert. There should only be one base
    * (i.e. a prepend or append.)
    *
    * @method appendBase
    * @param {string} base - The base string we will append to the rendered Insert
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.appendBase = function(base) {
      this.base = { str: base, position: this.POSITION_APPEND };
      return this;
    };

    /**
    * Adds a base to append to the rendered Insert. There should only be one base
    * (i.e. a prepend or append.)
    *
    * @method joinedBy
    * @param {string} joiner - The character(s) that we will join our whenCase strings with (i.e. space " " or newline "\n")
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.joinedBy = function(joiner) {
      this.joiner = joiner;
      return this;
    };

    /**
    * Renders the Insert based on the chosenOptions and returns a string to put in
    * the DOM. Expects an array of ["Type","Choice"] options to compare with the
    * Insert's `whenCase`s. For example, `chosenOptionsArr` might be:
    *
    *     [ ["Size","small"], ["Type","primary"] ]
    *
    * @method render
    * @param {Array} chosenOptionsArr - An array of arrays with the chosen options.
    * @return {string} renderedString - Returns a rendered string to put in the DOM.
    */
    PxSassInsert.prototype.render = function(chosenOptionsArr) {
      // Map over chosen options and build string
      var combinedStr = chosenOptionsArr.map(function(chosenOption){
        var type = chosenOption[0] || "", // Size
            choice = chosenOption[1] || ""; // small

        // Render whenCases based on the selectedChoice
        var whenCaseStr = this._renderWhenCases(type,choice);

        // Return the string, trimming leading/trailing whitespace
        return whenCaseStr.trim();
      }.bind(this)).join(this.joiner);

      // Return the final string to render with base
      return this._renderWithBase(combinedStr).trim();
    };

    /**
    * [PRIVATE] Renders the given string with the base prepended or appended.
    *
    * @method _renderWithBase
    * @param {string} str - A string to combine with the base.
    * @return {string} combinedStr - Combined string.
    */
    PxSassInsert.prototype._renderWithBase = function(str) {
      // Prepend or append base, depending on what the user wanted
      if (this.base) {
        if (this.base.position === this.POSITION_PREPEND) {
          str = this.base.str + this.joiner + str;
        }
        if (this.base.position === this.POSITION_APPEND) {
          str = str + this.joiner + this.base.str;
        }
      }
      return str || "";
    };

    /**
    * [PRIVATE] Renders a string of only the `whenCase`s that are selected.
    *
    * @method _renderWhenCases
    * @param {string} type - The type of option selected.
    * @param {string} choice - The choice selected in that option.
    * @return {string} renderedCases - A string of joined `whenCase`s.
    */
    PxSassInsert.prototype._renderWhenCases = function(type,choice) {
      // Loop through attached cases and return a string ready to render
      if (this.whenCases.length > 0) {
        // Prep the array we want to render from cases
        return this.whenCases
                  .filter(function(kase){
                    return kase.choice === choice && kase.optionName === type;
                  })
                  .map(function(kase){
                    return kase.str;
                  })
                  .join(this.joiner);
      }
      // If there's nothing, return an empty string
      return "";
    };

    /**
    * Adds a `whenCase` to this Insert. Usually called by `PxSassWhenCase.in()`.
    *
    * @method attachWhenCase
    * @param {Object} whenCaseObj - The `whenCase` object to attach.
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.attachWhenCase = function(whenCaseObj) {
      // Add the case if we don't already have it
      if (!this.whenCases.indexOf(whenCaseObj) > -1) {
        this.whenCases.push(whenCaseObj);
      }
      return this;
    };

  /**
  * Constructor that creates a new WhenCase object with special behaviors. We use it
  * to build a WhenCase that can be attached to an Insert to declaratively render
  * a string for building demo snippets.
  *
  * # Building WhenCases
  * WhenCase methods are chainable. The best way to use the methods is to make changes
  * immediately after you create the WhenCase. Example:
  *
  *     var whenCase = new PxSassWhenCase("Size",el).is("large").include("btn--large").in("classInsert");
  *
  * The following methods can be chained:
  * - is
  * - include
  * - in
  *
  * @constructor PxSassWhenCase
  * @param {string} optionName - The name of the option.
  * @param {Object} polymerEl - A reference to the Polymer element that owns this Insert.
  * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
  */
  var PxSassWhenCase = function(optionName, polymerEl) {
    this.optionName = optionName;
    this.polymerEl = polymerEl;
    return this;
  }

    /**
    * Specifies the choice this WhenCase applies to. The choice is a child of the
    * option specified when the constructor was first called (`this.optionName`).
    *
    * @method is
    * @param {string} choice - The name of the choice this WhenCase applies to.
    * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
    */
    PxSassWhenCase.prototype.is = function(choice) {
      this.choice = choice;
      return this;
    };

    /**
    * The string to render if this WhenCase is true. This will be added to the
    * rendered string of the Insert this WhenCase is attached to.
    *
    * @method include
    * @param {string} str - The string to render if this WhenCase is true.
    * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
    */
    PxSassWhenCase.prototype.include = function(str) {
      this.str = str;
      return this;
    };

    /**
    * The name of the Insert we want to attach this WhenCase to. When called, this
    * method updates the specified Insert with a reference to this WhenCase.
    *
    * @method in
    * @param {string} insertName - The name of the Insert to attach this WhenCase to.
    * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
    */
    PxSassWhenCase.prototype.in = function(insertName) {
      this.insert = this.polymerEl._inserts[insertName];
      this.insert.attachWhenCase(this);
      return this;
    };
</script>
