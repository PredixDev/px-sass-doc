<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. tests, examples), we assume the server is started with
    'gulp serve' (or similar server setup) to enable correct finding of bower dependencies for local runs.
-->
<link rel="import" href="../polymer/polymer.html"/>

<link rel="import" href="css/px-sass-doc-viewer-styles.html">
<link rel="import" href="../px-clipboard/px-clipboard.html">
<link rel="import" href="../prism-element/prism-highlighter.html" />
<link rel="import" href="../px-dropdown/px-dropdown.html"/>

<!--
Element providing documentation for a requested Predix UI Sass component (design library).

##### Usage

      <px-sass-doc-viewer
        library-name="px-toggle-design"
        layer="objects"
        base-name="toggle"
        inuit-flags='["$inuit-enable-toggle--small","$inuit-enable-toggle--large","$inuit-enable-toggle--huge"]'
        usage-html='["<input id=\"toggle1\" class=\"toggle__input\" type=\"checkbox\">","<label for=\"toggle1\" class=\"toggle__label\"></label>"]'
        style-variables='["$inuit-toggle-color","$inuit-toggle-background","$inuit-toggle-border","$inuit-toggle-switch","$inuit-toggle-switch-border","$inuit-toggle-switch-shadow","$inuit-toggle-background--on","$inuit-toggle-border--on"]'
        dependencies='["https://github.com/PredixDev/px-colors-design","https://github.com/PredixDev/px-defaults-design","https://github.com/PredixDev/px-helpers-design"]'>
      </px-sass-doc-viewer>

@element px-sass-doc-viewer
@blurb Element providing documentation for a requested Predix UI Sass component (design library).
@homepage index.html
@demo index.html
-->

<dom-module id="px-sass-doc-viewer">
  <template>
    <style include="px-sass-doc-viewer-styles"></style>
    <prism-highlighter></prism-highlighter>

    <div style="position: relative;" class="u-pb++ flex flex--col">
          <section>
            <div class="mega-demo flex u-ph++ u-pb++">
              <div class="properties u-ph+ u-pb+ u-mt+">
              <p class="epsilon">Style Options</p>
              <template is="dom-repeat" items="{{_computedStyleOptions}}">
                  <template is="dom-if" if="{{_isEqual(item.type,'dropdown')}}">
                    <div class="u-mb-">{{item.name}}:
                      <div style="width: 100%;">
                        <px-dropdown id="{{item.id}}" display-value="{{item.selectedValue}}">
                          <px-dropdown-content
                            items="{{item.dropdownItems}}">
                          </px-dropdown-content>
                        </px-dropdown>
                      </div>
                    </div>
                  </template>
                  <template is="dom-if" if="{{_isEqual(item.type,'boolean')}}">
                    <div class="flex u-mb-">
                      <input id="{{item.id}}" class="toggle__input toggle__input--small" type="checkbox" checked="{{item.selectedValue::change}}">
                      <label for$="{{item.id}}" class="toggle__label toggle__label--small"></label>
                      <div class="u-ml-">{{item.name}}</div>
                    </div>
                  </template>
              </template>
            </div>

            <div class="demoContainer u-mt+">
                <div class="flex flex--col">
                  <div class="demo u-p+">
                    <div class="flex u-mb-">
                      <content id="htmlDemo" select="#htmlDemo"></content>
                    </div>
                    <h4>Sass Import:</h4>
                    <px-clipboard copy-from="#importDemo">
                      <figure class="code u-mr-">
                        <code id="import">
                          <content id="importCode" select="#importDemo"></content>
                        </code>
                      </figure>
                    </px-clipboard>
                    <h4>HTML Usage:</h4>
                    <px-clipboard copy-from="#htmlDemoUsage">
                      <figure class="code u-mr-">
                        <code id="htmlDemoUsage"></code>
                      </figure>
                    </px-clipboard>
                </div>
              </div>
            </div>
          </div>
          <div class="apiContainer">
            <div class="flex flex--col api u-mt++">
              <div class="componentHeader">Installation</div>
              <p>Install via command line:</p>
              <px-clipboard copy-from="#install">
                <figure class="code u-mr-">
                  <code id="install">
                    bower install --save {{libraryName}}
                  </code>
                </figure>
              </px-clipboard>

              <div class="componentHeader">Import</div>
                <template is="dom-if" if="{{inuitFlags}}">
                  <p>The following flags are available and, if necessary, should be set to true <strong>prior to the import</strong> statement below.</p>
                  <px-clipboard copy-from="#enable">
                    <figure class="code u-mr-">
                      <code id="enable">
                        <template is="dom-repeat" items="{{inuitFlags}}">
                          {{item}} : true;<br/>
                        </template>
                      </code>
                    </figure>
                  </px-clipboard>
                </template>

                  <p>Include the required import below in your Sass file in the <strong>{{layer}}</strong> layer: <a href="https://github.com/PredixDev/px-getting-started#import-order" target="_blank"><iron-icon icon="fa:fa-question-circle" class="u-mh--"></iron-icon>What's this?</a></p>
                  <px-clipboard copy-from="#import2">
                    <figure class="code u-mr-">
                      <code id="import2">
                        {{_importCode}}
                      </code>
                    </figure>
                  </px-clipboard>

                  <div class="componentHeader">Usage</div>
                  <p>Include the following HTML in your main application to use the element:</p>
                  <px-clipboard copy-from="#usage2">
                    <figure class="code u-mr-">
                      <code id="usage2">
                        <template is="dom-repeat" items="{{usageHtml}}">
                          {{item}} <br/>
                        </template>
                      </code>
                    </figure>
                  </px-clipboard>

                  <template is="dom-if" if="{{styleVariables}}">
                    <div class="componentHeader">Customization</div>
                    <p>The following variables are available to customize the style of this element:</p>
                    <px-clipboard copy-from="#customize">
                      <figure class="code u-mr-">
                        <code id="customize">
                          <template is="dom-repeat" items="{{styleVariables}}">
                            {{item}} <br/>
                          </template>
                        </code>
                      </figure>
                    </px-clipboard>
                  </template>

                  <template is="dom-if" if="{{dependencies}}">
                    <div class="componentHeader">Dependencies</div>
                    <p>This module depends on the following modules (automatically included with Bower install):
                      <ul>
                        <template is="dom-repeat" items="{{dependencies}}">
                          <li><a class="actionable" href="{{item}}" target="_blank">{{item}}</a></li>
                        </template>
                      </ul>
                    </p>
                  </template>

            </div>
          </div>
        </section>
      </div>



  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-sass-doc-viewer',

    /**
     * Properties block, expose attribute values to the DOM via 'notify'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
      * Name of the overall sass repository.
      *
      * @property libraryName
      * @type String
      **/
      libraryName: {
        type: String,
        value: ''
      },
      /**
      * Inuit flags that are used to enable features and functionality, represented as an array of strings, which will display with line breaks between each.
      *
      * @property inuitFlags
      * @type Array
      */
      inuitFlags: {
        type: Array,
        value: function() { return []; }
      },
      /**
      *  ITCSS layer that this component belongs in, e.g. generic, objects, trumps, etc.
      *
      * @property layer
      * @type String
      */
      layer: {
        type: String,
        value: ''
      },
      /**
      * Base name of the component in the file path, e.g. _objects.BASENAME.scss.
      *
      * @property baseName
      * @type String
      */
      baseName: {
        type: String,
        value: ''
      },
      /**
      * The HTML code snippet to actually use the component, represented as an array of strings. A newline will appear between each string in the array. Include an empty string to result in an extra line break.
      *
      * @property usageHtml
      * @type Array
      */
      usageHtml: {
        type: Array,
        value: function() { return []; }
      },
      /**
      * The SASS variables available for customizing the appearance of the component, represented as an array of strings, which will display with line breaks between each.
      *
      * @property styleVariables
      * @type Array
      */
      styleVariables: {
        type: Array,
        value: function() { return []; }
      },
      /**
      * Any dependencies that exist for this component, represented as an array of strings, which will display in a list. Each string item should be the fully qualified URL of the repo.
      *
      * @property dependencies
      * @type Array
      */
      dependencies: {
        type: Array,
        value: function() { return [];}
      },
      /**
      * Array of objects representing the options to populate on the left side of the mega demo.
      * Each object should contain:
      * - label (to place above or next to the option)
      * - type ("dropdown" or "boolean")
      * - id (for the selector)
      * - dropdownItems (only applies for type dropdown)
      * - selectedValue (only applies for type dropdown)
      *
      * @property styleOptionsArray
      * @type Array
      */
      styleOptionsArray: {
        type: Array,
        value: function() { return []; }
      },
      /**
      * Array of objects representing the options that can be changed for this demo.
      * Each object should contain:
      * - {string} name - The name of the option (to place above or next to the option)
      * - {string} type - The type of the object ("dropdown" or "boolean")
      *
      * If the option will be displayed as a dropdown, provide an array of `choices` in the object:
      * - {Array} choices: An array of choices. Each should either be a string (e.g. "small") or an object
      *                    with the keys `name` and `isDefault` (e.g. { name: "small", isDefault: true })
      *
      * If the option will be displayed as a boolean, just specify a `defaultChoice`:
      * - {boolean} defaultChoice: A boolean that describes if this option should appear as `true` or `false` by default.
      *
      * @property styleOptions
      * @type Array
      */
      styleOptions: {
        type: Array,
        value: function() { return []; }
      },
      /**
      * An array of objects that is computed from `options` to provide the boilerplate
      * we need to create
      *
      * @property _computedOptions
      * @type Array
      */
      _computedStyleOptions: {
        type: Array,
        value: function() { return []; }
      },
      /**
      * Composed string that represents the import statement of the sass component.
      *
      * @property _importCode
      * @type String
      */
      _importCode: {
        type: String,
        computed: '_calculateImportCode(libraryName,layer,baseName)'
      },
      /**
      * Represents the options that are selected at the time. Used by external components to update themselves based on what options are selected.
      *
      * @property selectedOptions
      * @type Object
      */
      selectedOptions: {
        type: Object,
        value: function() { return {}; }
      },
      /**
      * @TODO doc this
      *
      * @property _inserts
      * @type Object
      */
      _inserts: {
        type: Object,
        value: function() { return {}; }
      },
      /**
      * @TODO doc this
      *
      * @property _cases
      * @type Array
      */
      _cases: {
        type: Array,
        value: function() { return []; }
      }
    },
    observers: ['_updateSelectedOptions(_computedStyleOptions.*)','_computeStyleOptions(styleOptions.*)'],
    attached: function() {
      // @TODO Put an observer on the light dom (to make sure the content slot has its content distributed)
      this._render();
    },
    /**
    * Computes the `options` to make the more verbose `_computedOptions` we need
    * for the px-dropdown-content component.
    *
    * @method _computeOptions
    */
    _computeStyleOptions: function() {
      this._computedStyleOptions = this.styleOptions.map(function(opt){
        if (opt.type === "dropdown") {
          return {
            name: opt.name,
            id: opt.name.replace(/ /g, '') + "SassDocDropdown",
            type: opt.type,
            dropdownItems: opt.choices.map(function(choice){
              if (typeof choice === "string") { return { "key": choice,      "val":choice }; };
              if (typeof choice === "object") { return { "key": choice.name, "val":choice.name };; };
            }),
            selectedValue: opt.choices.filter(function(choice){ return (typeof choice === "object") && (choice.isDefault) })[0].name
          }
        }
        if (opt.type === "boolean") {
          return {
            name: opt.name,
            id: opt.name.replace(/ /g, '') + "SassDocDropdown",
            type: opt.type,
            selectedValue: opt.defaultChoice
          }
        }
      });
    },
    createInsert: function(name) {
      this._inserts[name] = new PxSassInsert(name, this);
      // this._inserts["classInsert"] = new PxSassInsert(classInsert, <px-sass-doc-viewer></px-sass-doc-viwer>);
      //
      return this._inserts[name];
    },
    whenOption: function(optionName) {
      var whenCase = new PxSassWhenCase(optionName, this);
      this._cases.push(whenCase);
      return whenCase;
    },
    /**
    * Method that composes the import statement from the constituent parts.
    *
    * @method _calculateImportCode
    * @param library
    * @param layer
    * @param base
    */
    _calculateImportCode: function(library,layer,base) {
      return '@import "' + library + '/_' + layer + '.' + base + '.scss";';
    },
    /**
    * Compares strings for dom-if logic.
    *
    * @method _isEqual
    * @param a
    * @param b
    */
    _isEqual: function(a, b) {
      return a === b;
    },
    /**
     * if the styleOptionsArray has a value run through each item, get the selectedValue, and assign it to selectedOptions
     */
    _updateSelectedOptions: function() {
      if (this._computedStyleOptions.length > 0) {
        // Get the selected options to use in each Insert render function
        this.selectedOptions = this._computedStyleOptions.map(function(option){
          return [ option.name, option.selectedValue ]
        });

        // Loop over each Insert and run its render function, pass the result
        var selectedOptions = this.selectedOptions,
            inserts = this._inserts;
        for (var key in inserts) {
          if (inserts.hasOwnProperty(key)) {
            var insert = inserts[key],
                insertStr = insert.render(selectedOptions);
            this.fire('px-sass-doc-viewer-selected-options-changed', { insert: insert.name, string: insertStr });
          }
        }
      }
    },
    /**
    * function to render the demo element that is created
    * called on attached and when style options is updated
    */
    _render: function() {
      var code = this.getContentChildren('#htmlDemo')[0].innerHTML,
          output = this._fireOutputEvent(code, 'html').replace(/\n/g, '').trim();
      if (output.substr(0, 5) !== '<span') {
        //prism highlighter hasn't loaded yet. run this again with async.
        this.async(this._render,50);
      } else {
        this.$.htmlDemoUsage.innerHTML = output;
      }
    },
    /**
    *
    * This method fires a syntax-highlight event (meant for prism-highlighter), and returns the code, with formatting.
    *
    * @method _fireOutputEvent
    * @return {Highlighted Code}
    */
    _fireOutputEvent: function(code, lang) {
      return this.fire('syntax-highlight', {code: code, lang: lang}).detail.code;
    }
  });

  /**
  * Constructor that creates a new Insert object with special behaviors. We use it
  * to build an "insertable" string that is passed up to the parent to use in
  * building demo snippets.
  *
  * # Building Inserts
  * Insert methods are chainable. The best way to use the methods is to make changes
  * immediately after you create the Insert. Example:
  *
  *     var insert = new PxSassInsert("insertName",el).prependBase("prepend-string").joinedBy("\n")
  *
  * The following methods can be chained:
  * - prependBase
  * - appendBase
  * - joinedBy
  * - attachWhenCase
  *
  * The following methods cannot be chained:
  * - render
  * - _renderWithBase
  * - _renderWhenCases
  *
  * @constructor PxSassInsert
  * @param {string} name - The name of the insert (will be fired with events).
  * @param {Object} polymerEl - A reference to the Polymer element that owns this Insert.
  * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
  */
  var PxSassInsert = function(name, polymerEl) {
    this.name = name;
    this.polymerEl = polymerEl;

    // Register additional necessary things
    this.whenCases = [];
    this.joiner = "";

    // Register constants
    this.POSITION_PREPEND = "prepend"
    this.POSITION_APPEND = "append"

    return this;
  };

    /**
    * Adds a base to prepend to the rendered Insert. There should only be one base
    * (i.e. a prepend or append.)
    *
    * @method prependBase
    * @param {string} base - The base string we will prepend to the rendered Insert
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.prependBase = function(base) {
      this.base = { str: base, position: this.POSITION_PREPEND };
      return this;
    };

    /**
    * Adds a base to append to the rendered Insert. There should only be one base
    * (i.e. a prepend or append.)
    *
    * @method appendBase
    * @param {string} base - The base string we will append to the rendered Insert
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.appendBase = function(base) {
      this.base = { str: base, position: this.APPEND_PREPEND };
      return this;
    };

    /**
    * Adds a base to append to the rendered Insert. There should only be one base
    * (i.e. a prepend or append.)
    *
    * @method joinedBy
    * @param {string} joiner - The character(s) that we will join our whenCase strings with (i.e. space " " or newline "\n")
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.joinedBy = function(joiner) {
      this.joiner = joiner;
      return this;
    };

    /**
    * Renders the Insert based on the chosenOptions and returns a string to put in
    * the DOM. Expects an array of ["Type","Choice"] options to compare with the
    * Insert's `whenCase`s. For example, `chosenOptionsArr` might be:
    *
    *     [ ["Size","small"], ["Type","primary"] ]
    *
    * @method render
    * @param {Array} chosenOptionsArr - An array of arrays with the chosen options.
    * @return {string} renderedString - Returns a rendered string to put in the DOM.
    */
    PxSassInsert.prototype.render = function(chosenOptionsArr) {
      // Map over chosen options and build string
      var combinedStr = chosenOptionsArr.map(function(chosenOption){
        var type = chosenOption[0] || "", // Size
            choice = chosenOption[1] || ""; // small

        // Render whenCases based on the selectedChoice
        var whenCaseStr = this._renderWhenCases(type,choice);

        // Return the string, trimming leading/trailing whitespace
        return whenCaseStr.trim();
      }.bind(this)).join(this.joiner);

      // Return the final string to render with base
      return this._renderWithBase(combinedStr);
    };

    /**
    * [PRIVATE] Renders the given string with the base prepended or appended.
    *
    * @method _renderWithBase
    * @param {string} str - A string to combine with the base.
    * @return {string} combinedStr - Combined string.
    */
    PxSassInsert.prototype._renderWithBase = function(str) {
      // Prepend or append base, depending on what the user wanted
      if (this.base) {
        if (this.base.position === this.POSITION_PREPEND) {
          str = this.base.str + this.joiner + str;
        }
        if (this.base.position === this.POSITION_APPEND) {
          str = str + this.joiner + this.base.str;
        }
      }
      return str || "";
    };

    /**
    * [PRIVATE] Renders a string of only the `whenCase`s that are selected.
    *
    * @method _renderWhenCases
    * @param {string} type - The type of option selected.
    * @param {string} choice - The choice selected in that option.
    * @return {string} renderedCases - A string of joined `whenCase`s.
    */
    PxSassInsert.prototype._renderWhenCases = function(type,choice) {
      // Loop through attached cases and return a string ready to render
      if (this.whenCases.length > 0) {
        // Prep the array we want to render from cases
        return this.whenCases
                  .filter(function(kase){
                    return kase.choice === choice && kase.optionName === type;
                  })
                  .map(function(kase){
                    return kase.str;
                  })
                  .join(this.joiner);
      }
      // If there's nothing, return an empty string
      return "";
    };

    /**
    * Adds a `whenCase` to this Insert. Usually called by `PxSassWhenCase.in()`.
    *
    * @method attachWhenCase
    * @param {Object} whenCaseObj - The `whenCase` object to attach.
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.attachWhenCase = function(whenCaseObj) {
      // Add the case if we don't already have it
      if (!this.whenCases.indexOf(whenCaseObj) > -1) {
        this.whenCases.push(whenCaseObj);
      }
      return this;
    };

  /**
  * Constructor that creates a new WhenCase object with special behaviors. We use it
  * to build a WhenCase that can be attached to an Insert to declaratively render
  * a string for building demo snippets.
  *
  * # Building WhenCases
  * WhenCase methods are chainable. The best way to use the methods is to make changes
  * immediately after you create the WhenCase. Example:
  *
  *     var whenCase = new PxSassWhenCase("Size",el).is("large").include("btn--large").in("classInsert");
  *
  * The following methods can be chained:
  * - is
  * - include
  * - in
  *
  * @constructor PxSassWhenCase
  * @param {string} optionName - The name of the option.
  * @param {Object} polymerEl - A reference to the Polymer element that owns this Insert.
  * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
  */
  var PxSassWhenCase = function(optionName, polymerEl) {
    this.optionName = optionName;
    this.polymerEl = polymerEl;
    return this;
  }

    /**
    * Specifies the choice this WhenCase applies to. The choice is a child of the
    * option specified when the constructor was first called (`this.optionName`).
    *
    * @method is
    * @param {string} choice - The name of the choice this WhenCase applies to.
    * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
    */
    PxSassWhenCase.prototype.is = function(choice) {
      this.choice = choice;
      return this;
    };

    /**
    * The string to render if this WhenCase is true. This will be added to the
    * rendered string of the Insert this WhenCase is attached to.
    *
    * @method include
    * @param {string} str - The string to render if this WhenCase is true.
    * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
    */
    PxSassWhenCase.prototype.include = function(str) {
      this.str = str;
      return this;
    };

    /**
    * The name of the Insert we want to attach this WhenCase to. When called, this
    * method updates the specified Insert with a reference to this WhenCase.
    *
    * @method in
    * @param {string} insertName - The name of the Insert to attach this WhenCase to.
    * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
    */
    PxSassWhenCase.prototype.in = function(insertName) {
      this.insert = this.polymerEl._inserts[insertName];
      this.insert.attachWhenCase(this);
      return this;
    };
</script>
