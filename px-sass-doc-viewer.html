<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. tests, examples), we assume the server is started with
    'gulp serve' (or similar server setup) to enable correct finding of bower dependencies for local runs.
-->
<link rel="import" href="../polymer/polymer.html"/>

<link rel="import" href="css/px-sass-doc-viewer-styles.html">
<link rel="import" href="../px-clipboard/px-clipboard.html">
<link rel="import" href="../prism-element/prism-highlighter.html" />
<link rel="import" href="../px-dropdown/px-dropdown.html"/>
<link rel="import" href="../iron-ajax/iron-ajax.html"/>
<link rel="import" href="../polymer-font-awesome/polymer-font-awesome.html" />
<link rel="import" href="../iron-collapse/iron-collapse.html" />
<link rel="import" href="../iron-icon/iron-icon.html" />
<link rel="import" href="px-highlighter.html" />

<!--
Element providing documentation for a requested Predix UI Sass component (design library).

##### Usage

      <px-sass-doc-viewer
        library-name="px-toggle-design"
        layer="objects"
        base-name="toggle"
        inuit-flags='["$inuit-enable-toggle--small","$inuit-enable-toggle--large","$inuit-enable-toggle--huge"]'
        usage-html='["<input id=\"toggle1\" class=\"toggle__input\" type=\"checkbox\">","<label for=\"toggle1\" class=\"toggle__label\"></label>"]'
        style-variables='["$inuit-toggle-color","$inuit-toggle-background","$inuit-toggle-border","$inuit-toggle-switch","$inuit-toggle-switch-border","$inuit-toggle-switch-shadow","$inuit-toggle-background--on","$inuit-toggle-border--on"]'
        dependencies='["https://github.com/PredixDev/px-colors-design","https://github.com/PredixDev/px-defaults-design","https://github.com/PredixDev/px-helpers-design"]'>
      </px-sass-doc-viewer>

@element px-sass-doc-viewer
@blurb Element providing documentation for a requested Predix UI Sass component (design library).
@homepage index.html
@demo index.html
-->

<dom-module id="px-sass-doc-viewer">
  <template>
    <style include="px-sass-doc-viewer-styles"></style>
    <style is="custom-style">
      .arrow--small {
        --iron-icon-height: 16px;
        --iron-icon-width: 16px;
      }
      .arrow--inactive {
        transform: rotate(-90deg);
      }
    </style>
    <prism-highlighter></prism-highlighter>
    <iron-ajax
        auto
        url="[[sassdocJsonPath]]"
        handle-as="json"
        last-response="{{_sassdocJson}}">
    </iron-ajax>

    <div class="apiContainer">
      <div class="flex flex--col api u-mt++">

        <!-- INSTALLATION -->
        <section class="u-mb++">
          <div class="componentHeader">Installation</div>
          <p>Install the module and any dependencies using Bower. Run this task from the command line inside your project folder:</p>
          <px-clipboard copy-from="#install">
            <figure class="code u-mr-">
              <code id="install">
                bower install --save {{libraryName}}
              </code>
            </figure>
          </px-clipboard>
        </section>

        <section class="u-mb++">
          <!-- IMPORT -->
          <div class="componentHeader">Enable and Import</div>
          <h3>Enable Flags</h3>
          <template is="dom-if" if="{{_hasFlags}}">
            <p>The following flags can be enabled to generate additional styles for the module. To use these styles, set the flags to true <strong>above the module @import statement</strong> in your project Sass file:</p>
          </template>
          <template is="dom-if" if="{{_hasIntuitFlags}}">
            <px-clipboard copy-from="#enable">
              <figure class="code u-mr-">
                <code id="install">
                  <template is="dom-repeat" items="{{inuitFlags}}">
                    {{item}} : true;<br/>
                  </template>
                </code>
              </figure>
            </px-clipboard>
          </template>
          <template is="dom-if" if="{{_hasSassdocIntuitFlags}}">
            <ul class="list-ui list-ui--large u-m++">
              <template is="dom-repeat" items="{{_sassdocIntuitFlags}}">
                <li class="list-ui__item">
                  <h4>
                    <a on-tap="_toggle"><iron-icon class="arrow--small arrow--inactive" icon="fa:fa-angle-down" data-toggle="{{item.context.name}}"></iron-icon></a>
                    ${{item.context.name}}
                    <small class="caps muted weight--light u-ml">Type: {{item.type}}</small>
                    <small class="caps muted weight--light u-ml">Default Value: {{item.context.value}}</small>
                  </h4>
                  <iron-collapse id="{{item.context.name}}-container" no-animation>
                    <p class="u-mt++">{{item.description}}</p>
                    <px-clipboard copy-from="#{{item.context.name}}-code">
                      <figure class="code u-mr-">
                        <code id="{{item.context.name}}-code">
                          ${{item.context.name}} : true;
                        </code>
                      </figure>
                    </px-clipboard>
                  </iron-collapse>
                </li>
              </template>
            </ul>
          </template>
          <template is="dom-if" if="{{!_hasFlags}}">
            <p>There are no flags to set before importing this module in your project Sass file.</p>
          </template>

          <!-- INCLUDE -->
          <h3>Import Sass</h3>
          <p>Import the module by placing this code into the <strong>{{layer}}</strong> layer of your project Sass file: <a href="https://github.com/PredixDev/px-getting-started#import-order" target="_blank"><iron-icon icon="fa:fa-question-circle" class="u-mh--"></iron-icon>What's this?</a></p>
          <px-clipboard copy-from="#import2">
            <figure class="code u-mr-">
              <code id="import2">
                {{_importCode}}
              </code>
            </figure>
          </px-clipboard>
        </section>

        <!-- USAGE -->
        <section class="u-mb++">
          <div class="componentHeader">Usage</div>
          <p>Include the following HTML in your project to use the module:</p>
          <px-clipboard copy-from="#usageHTML">
            <px-highlighter highlight-target="#usageHTML">
              <content select="[data-slot=usageHTML]"></content>
            </px-highlighter>
            <pre class="code u-mr- u-mb">
              <code id="usageHTML" class="import-code"></code>
            </pre>
          </px-clipboard>
        </section>

        <!-- CUSTOMIZATION -->
        <template is="dom-if" if="{{_hasStyles}}">
          <div class="componentHeader">Customization</div>
          <p>The following variables are available to customize the style of this element:</p>
        </template>
        <template is="dom-if" if="{{_hasStyleVariables}}">
          <section class="u-mb++">
            <px-clipboard copy-from="#customize">
              <figure class="code u-mr-">
                <code id="customize">
                  <template is="dom-repeat" items="{{styleVariables}}">
                    {{item}} <br/>
                  </template>
                </code>
              </figure>
            </px-clipboard>
          </section>
        </template>
        <template is="dom-if" if="{{_hasSassdocStyleVariables}}">
          <ul class="list-ui list-ui--large u-m++">
            <template is="dom-repeat" items="{{_sassdocStyleVariables}}">
              <li class="list-ui__item">
                <h4>
                  <a on-tap="_toggle"><iron-icon class="arrow--small arrow--inactive" icon="fa:fa-angle-down" data-toggle="{{item.context.name}}"></iron-icon></a>
                  ${{item.context.name}}
                  <small class="caps muted weight--light u-ml">Type: {{item.type}}</small>
                  <small class="caps muted weight--light u-ml">Default Value: {{item.context.value}}</small>
                </h4>
                <iron-collapse id="{{item.context.name}}-container" no-animation>
                  <p class="u-mt++">{{item.description}}</p>
                  <px-clipboard copy-from="#{{item.context.name}}-code">
                    <figure class="code u-mr-">
                      <code id="{{item.context.name}}-code">
                        ${{item.context.name}} : {{item.context.value}};
                      </code>
                    </figure>
                  </px-clipboard>
                </iron-collapse>
              </li>
            </template>
          </ul>
        </template>

        <!-- DEPENDENCIES -->
        <section class="u-mb++">
          <div class="componentHeader">Dependencies</div>
          <template is="dom-if" if="{{_hasDependencies}}">
            <p>This module depends on the following modules (automatically included with Bower install):
              <ul>
                <template is="dom-repeat" items="{{dependencies}}">
                  <li><a class="actionable" href="{{item}}" target="_blank">{{item}}</a></li>
                </template>
              </ul>
            </p>
          </template>
          <template is="dom-if" if="{{!_hasDependencies}}">
            <p>This module doesn't have any dependencies.</p>
          </template>
        </section>

      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-sass-doc-viewer',

    /**
     * Properties block, expose attribute values to the DOM via 'notify'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
      * Name of the overall sass repository.
      *
      * @property libraryName
      * @type String
      **/
      libraryName: {
        type: String,
        value: ''
      },
      /**
      * Inuit flags that are used to enable features and functionality, represented as an array of strings, which will display with line breaks between each.
      *
      * @property inuitFlags
      * @type Array
      */
      inuitFlags: {
        type: Array,
        value: function() { return []; }
      },
      /**
      * PRIVATE. Is true if intuitFlags and _sassdocIntuitFlags aren't empty.
      *
      * @property _hasIntuitFlags
      * @type boolean
      */
      _hasIntuitFlags: {
        type: Boolean,
        value: false,
        computed: '_hasSome(inuitFlags)'
      },
      /**
      *  ITCSS layer that this component belongs in, e.g. generic, objects, trumps, etc.
      *
      * @property layer
      * @type String
      */
      layer: {
        type: String,
        value: ''
      },
      /**
      * Base name of the component in the file path, e.g. _objects.BASENAME.scss.
      *
      * @property baseName
      * @type String
      */
      baseName: {
        type: String,
        value: ''
      },
      /**
      * The HTML code snippet to actually use the component, represented as an array of strings. A newline will appear between each string in the array. Include an empty string to result in an extra line break.
      *
      * @property usageHtml
      * @type Array
      */
      usageHtml: {
        type: Array,
        value: function() { return []; }
      },
      /**
      * The SASS variables available for customizing the appearance of the component, represented as an array of strings, which will display with line breaks between each.
      *
      * @property styleVariables
      * @type Array
      */
      styleVariables: {
        type: Array,
        value: function() { return []; }
      },
      _hasStyleVariables: {
        type: Boolean,
        value: false,
        computed: '_hasSome(styleVariables)'
      },
      /**
      * Any dependencies that exist for this component, represented as an array of strings, which will display in a list. Each string item should be the fully qualified URL of the repo.
      *
      * @property dependencies
      * @type Array
      */
      dependencies: {
        type: Array,
        value: function() { return []; }
      },
      /**
      * PRIVATE. Is true if dependencies isn't empty.
      *
      * @property _hasDependencies
      * @type boolean
      */
      _hasDependencies: {
        type: Boolean,
        value: false,
        computed: '_hasSome(dependencies)'
      },
      /**
      * Composed string that represents the import statement of the sass component.
      *
      * @property _importCode
      * @type String
      */
      _importCode: {
        type: String,
        computed: '_calculateImportCode(libraryName,layer,baseName)'
      },
      sassdocJsonPath: {
        type: String
      },
      _sassdocJson: {
        type: Array,
        value: function(){ []; }
      },
      _sassdocStyleVariables: {
        type: Array,
        value: function(){ []; },
        computed: '_computeSassdocStyleVariables(_sassdocJson)'
      },
      _hasSassdocStyleVariables: {
        type: Boolean,
        value: false,
        computed: '_hasSome(_sassdocStyleVariables)'
      },
      _sassdocIntuitFlags: {
        type: Array,
        value: function(){ []; },
        computed: '_computeSassdocIntuitFlags(_sassdocJson)'
      },
      _hasSassdocIntuitFlags: {
        type: Boolean,
        value: false,
        computed: '_hasSome(_sassdocIntuitFlags)'
      },
      _hasFlags: {
        type: Boolean,
        value: false
      },
      _hasStyles: {
        type: Boolean,
        value: false
      },
    },
    observers: [
      '_computeHasFlags(intuitFlags)', '_computeHasFlags(_sassdocIntuitFlags)',
      '_computeHasStyles(styleVariables)', '_computeHasStyles(_sassdocStyleVariables)'
    ],
    _computeHasFlags: function() {
      this._hasFlags = this._hasSome(this.intuitFlags) || this._hasSome(this._sassdocIntuitFlags);
    },
    _computeHasStyles: function() {
      this._hasStyles = this._hasSome(this.styleVariables) || this._hasSome(this._sassdocStyleVariables);
    },
    _computeSassdocStyleVariables: function() {
      return this._sassdocJson.filter(function(docItem){
        return docItem.group && docItem.group.indexOf('px-toggle-design:variables:style') > -1;
      });
    },
    _computeSassdocIntuitFlags: function() {
      return this._sassdocJson.filter(function(docItem){
        return docItem.group && docItem.group.indexOf('px-toggle-design:variables:flag') > -1;
      });
    },
    /**
    * Method that composes the import statement from the constituent parts.
    *
    * @method _calculateImportCode
    * @param library
    * @param layer
    * @param base
    */
    _calculateImportCode: function(library,layer,base) {
      return '@import "' + library + '/_' + layer + '.' + base + '.scss";';
    },
    /**
    * Method that determines if this element has a property or method with the
    * key provided, and checks if the value of that key has a length.
    *
    * @method _hasSome
    * @param {String} thing - a string representing the key of the property or method
    * @return {Boolean}
    */
    _hasSome: function(arr) {
      arr = arr || [];
      return arr.length > 0;
    },
    _toggle: function(evt) {
      var source = evt.target,
          target = '#' + evt.target.dataToggle + '-container';
      this.$$(target).toggle();
      this._toggleArrow(source);
    },
    _toggleArrow: function(el) {
      el.classList.toggle('arrow--inactive');
    }
  });

  /**
  * Constructor that creates a new Insert object with special behaviors. We use it
  * to build an "insertable" string that is passed up to the parent to use in
  * building demo snippets.
  *
  * # Building Inserts
  * Insert methods are chainable. The best way to use the methods is to make changes
  * immediately after you create the Insert. Example:
  *
  *     var insert = new PxSassInsert("insertName",el).prependBase("prepend-string").joinedBy("\n")
  *
  * The following methods can be chained:
  * - prependBase
  * - appendBase
  * - joinedBy
  * - attachWhenCase
  *
  * The following methods cannot be chained:
  * - render
  * - _renderWithBase
  * - _renderWhenCases
  *
  * @constructor PxSassInsert
  * @param {string} name - The name of the insert (will be fired with events).
  * @param {Object} polymerEl - A reference to the Polymer element that owns this Insert.
  * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
  */
  var PxSassInsert = function(name, polymerEl) {
    this.name = name;
    this.polymerEl = polymerEl;

    // Register additional necessary things
    this.whenCases = [];
    this.joiner = "";

    // Register constants
    this.POSITION_PREPEND = "prepend"
    this.POSITION_APPEND = "append"

    return this;
  };

    /**
    * Adds a base to prepend to the rendered Insert. There should only be one base
    * (i.e. a prepend or append.)
    *
    * @method prependBase
    * @param {string} base - The base string we will prepend to the rendered Insert
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.prependBase = function(base) {
      this.base = { str: base, position: this.POSITION_PREPEND };
      return this;
    };

    /**
    * Adds a base to append to the rendered Insert. There should only be one base
    * (i.e. a prepend or append.)
    *
    * @method appendBase
    * @param {string} base - The base string we will append to the rendered Insert
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.appendBase = function(base) {
      this.base = { str: base, position: this.POSITION_APPEND };
      return this;
    };

    /**
    * Adds a base to append to the rendered Insert. There should only be one base
    * (i.e. a prepend or append.)
    *
    * @method joinedBy
    * @param {string} joiner - The character(s) that we will join our whenCase strings with (i.e. space " " or newline "\n")
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.joinedBy = function(joiner) {
      this.joiner = joiner;
      return this;
    };

    /**
    * Renders the Insert based on the chosenOptions and returns a string to put in
    * the DOM. Expects an array of ["Type","Choice"] options to compare with the
    * Insert's `whenCase`s. For example, `chosenOptionsArr` might be:
    *
    *     [ ["Size","small"], ["Type","primary"] ]
    *
    * @method render
    * @param {Array} chosenOptionsArr - An array of arrays with the chosen options.
    * @return {string} renderedString - Returns a rendered string to put in the DOM.
    */
    PxSassInsert.prototype.render = function(chosenOptionsArr) {
      // Map over chosen options and build string
      var combinedStr = chosenOptionsArr.map(function(chosenOption){
        var type = chosenOption[0] || "", // Size
            choice = chosenOption[1] || ""; // small

        // Render whenCases based on the selectedChoice
        var whenCaseStr = this._renderWhenCases(type,choice);

        // Return the string, trimming leading/trailing whitespace
        return whenCaseStr.trim();
      }.bind(this)).join(this.joiner);

      // Return the final string to render with base
      return this._renderWithBase(combinedStr).trim();
    };

    /**
    * [PRIVATE] Renders the given string with the base prepended or appended.
    *
    * @method _renderWithBase
    * @param {string} str - A string to combine with the base.
    * @return {string} combinedStr - Combined string.
    */
    PxSassInsert.prototype._renderWithBase = function(str) {
      // Prepend or append base, depending on what the user wanted
      if (this.base) {
        if (this.base.position === this.POSITION_PREPEND) {
          str = this.base.str + this.joiner + str;
        }
        if (this.base.position === this.POSITION_APPEND) {
          str = str + this.joiner + this.base.str;
        }
      }
      return str || "";
    };

    /**
    * [PRIVATE] Renders a string of only the `whenCase`s that are selected.
    *
    * @method _renderWhenCases
    * @param {string} type - The type of option selected.
    * @param {string} choice - The choice selected in that option.
    * @return {string} renderedCases - A string of joined `whenCase`s.
    */
    PxSassInsert.prototype._renderWhenCases = function(type,choice) {
      // Loop through attached cases and return a string ready to render
      if (this.whenCases.length > 0) {
        // Prep the array we want to render from cases
        return this.whenCases
                  .filter(function(kase){
                    return kase.choice === choice && kase.optionName === type;
                  })
                  .map(function(kase){
                    return kase.str;
                  })
                  .join(this.joiner);
      }
      // If there's nothing, return an empty string
      return "";
    };

    /**
    * Adds a `whenCase` to this Insert. Usually called by `PxSassWhenCase.in()`.
    *
    * @method attachWhenCase
    * @param {Object} whenCaseObj - The `whenCase` object to attach.
    * @return {Object} this - Returns `this`, a reference to the Insert, to allow chaining methods.
    */
    PxSassInsert.prototype.attachWhenCase = function(whenCaseObj) {
      // Add the case if we don't already have it
      if (!this.whenCases.indexOf(whenCaseObj) > -1) {
        this.whenCases.push(whenCaseObj);
      }
      return this;
    };

  /**
  * Constructor that creates a new WhenCase object with special behaviors. We use it
  * to build a WhenCase that can be attached to an Insert to declaratively render
  * a string for building demo snippets.
  *
  * # Building WhenCases
  * WhenCase methods are chainable. The best way to use the methods is to make changes
  * immediately after you create the WhenCase. Example:
  *
  *     var whenCase = new PxSassWhenCase("Size",el).is("large").include("btn--large").in("classInsert");
  *
  * The following methods can be chained:
  * - is
  * - include
  * - in
  *
  * @constructor PxSassWhenCase
  * @param {string} optionName - The name of the option.
  * @param {Object} polymerEl - A reference to the Polymer element that owns this Insert.
  * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
  */
  var PxSassWhenCase = function(optionName, polymerEl) {
    this.optionName = optionName;
    this.polymerEl = polymerEl;
    return this;
  }

    /**
    * Specifies the choice this WhenCase applies to. The choice is a child of the
    * option specified when the constructor was first called (`this.optionName`).
    *
    * @method is
    * @param {string} choice - The name of the choice this WhenCase applies to.
    * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
    */
    PxSassWhenCase.prototype.is = function(choice) {
      this.choice = choice;
      return this;
    };

    /**
    * The string to render if this WhenCase is true. This will be added to the
    * rendered string of the Insert this WhenCase is attached to.
    *
    * @method include
    * @param {string} str - The string to render if this WhenCase is true.
    * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
    */
    PxSassWhenCase.prototype.include = function(str) {
      this.str = str;
      return this;
    };

    /**
    * The name of the Insert we want to attach this WhenCase to. When called, this
    * method updates the specified Insert with a reference to this WhenCase.
    *
    * @method in
    * @param {string} insertName - The name of the Insert to attach this WhenCase to.
    * @return {Object} this - Returns `this`, a reference to the WhenCase, to allow chaining methods.
    */
    PxSassWhenCase.prototype.in = function(insertName) {
      this.insert = this.polymerEl._inserts[insertName];
      this.insert.attachWhenCase(this);
      return this;
    };
</script>
